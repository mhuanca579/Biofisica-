<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>NeuroNav-NanoTwin ‚Ä¢ Simulaci√≥n (BBB + gu√≠a magn√©tica)</title>
<style>
  :root{
    --bg:#050814; --txt:#e9ecff; --mut:rgba(233,236,255,.75);
    --b:rgba(255,255,255,.12); --acc:#38bdf8; --acc2:#a78bfa;
    --good:#22c55e; --warn:#fbbf24; --bad:#fb7185;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--txt);font-family:Arial;overflow:hidden}
  .wrap{display:grid;grid-template-columns:380px 1fr;height:100vh}
  aside{padding:14px;border-right:1px solid rgba(255,255,255,.10);background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.02));overflow:auto}
  h2{margin:0 0 6px;font-size:18px}
  .hint{font-size:12px;color:var(--mut);line-height:1.35;margin-bottom:10px}
  label{display:block;margin:10px 0 6px;color:var(--mut);font-size:12px}
  .val{float:right;font-weight:900;color:rgba(233,236,255,.9)}
  input[type="range"],select{width:100%}
  .row{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  button{
    flex:1;min-width:120px;border:1px solid var(--b);
    background:rgba(255,255,255,.06);color:var(--txt);padding:10px;border-radius:12px;
    cursor:pointer;font-weight:900
  }
  button.primary{border-color:rgba(56,189,248,.35);background:rgba(56,189,248,.12)}
  .kpis{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px}
  .kpi{border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.22);border-radius:14px;padding:10px}
  .kpi div{font-size:12px;color:var(--mut)}
  .kpi b{font-size:18px}
  main{padding:12px}
  canvas{width:100%;display:block;border-radius:16px;background:#000;border:2px solid rgba(56,189,248,.35)}
  .legend{margin-top:10px;font-size:12px;color:var(--mut);line-height:1.35}
  .pill{display:inline-block;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06)}
  @media(max-width:980px){body{overflow:auto}.wrap{grid-template-columns:1fr;height:auto}}
</style>
</head>
<body>

<div class="wrap">
  <aside>
    <h2>NeuroNav-NanoTwin</h2>
    <div class="hint">
      Modelo educativo simplificado: <b>sangre ‚Üí BBB ‚Üí tumor</b>. La gu√≠a magn√©tica y la permeabilidad BBB aumentan el cruce al tumor; los pulsos controlan cu√°ndo liberar.
    </div>

    <label>Tipo de nanorrobot</label>
    <select id="type">
      <option value="mag">Magneto-guiado (principal)</option>
      <option value="lig">Ligandos (afinidad bioqu√≠mica)</option>
      <option value="mix">H√≠brido (mag + ligandos)</option>
    </select>

    <label>Dosis (cantidad) <span class="val" id="vDose">240</span></label>
    <input id="dose" type="range" min="80" max="520" step="1" value="240">

    <label>Flujo sangu√≠neo (convecci√≥n) <span class="val" id="vFlow">1.3</span></label>
    <input id="flow" type="range" min="0.6" max="2.6" step="0.1" value="1.3">

    <label>Campo magn√©tico (gu√≠a) <span class="val" id="vB">65</span></label>
    <input id="B" type="range" min="0" max="100" step="1" value="65">

    <label>Permeabilidad BBB (apertura) <span class="val" id="vBBB">35</span></label>
    <input id="bbb" type="range" min="0" max="100" step="1" value="35">

    <label>Pulsos de activaci√≥n (liberar en tumor) <span class="val" id="vPulse">50</span></label>
    <input id="pulse" type="range" min="0" max="100" step="1" value="50">

    <label>Liberaci√≥n en tumor (k_release) <span class="val" id="vRel">55</span></label>
    <input id="rel" type="range" min="0" max="100" step="1" value="55">

    <label>Fuga fuera del objetivo (off-target) <span class="val" id="vLeak">18</span></label>
    <input id="leak" type="range" min="0" max="100" step="1" value="18">

    <label>Aclaramiento (h√≠gado/ri√±√≥n) <span class="val" id="vClear">25</span></label>
    <input id="clear" type="range" min="0" max="100" step="1" value="25">

    <div class="row">
      <button id="inject" class="primary">üíâ Inyectar</button>
      <button id="boost">‚ûï Refuerzo</button>
      <button id="reset">üîÑ Reiniciar</button>
    </div>

    <div class="kpis">
      <div class="kpi"><div>% llega al tumor</div><b id="kReach">0%</b></div>
      <div class="kpi"><div>AUC tumor (sim.)</div><b id="kAUCT">0.0</b></div>
      <div class="kpi"><div>Exposici√≥n sana</div><b id="kTox">0%</b></div>
      <div class="kpi"><div>Control tumoral</div><b id="kCtrl">85%</b></div>
    </div>

    <div class="hint" id="status" style="margin-top:10px">Estado: esperando inyecci√≥n.</div>

    <div class="legend">
      <span class="pill">Azul</span> nanorrobots con f√°rmaco ¬∑
      <span class="pill">Amarillo</span> descargados ¬∑
      <span class="pill">BBB</span> barrera ¬∑
      Heatmap: brillo = f√°rmaco en tumor
    </div>
  </aside>

  <main>
    <canvas id="cv" width="1200" height="720"></canvas>
  </main>
</div>

<script>
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d");

const ui = {
  type: type, dose:dose, flow:flow, B:B, bbb:bbb, pulse:pulse, rel:rel, leak:leak, clear:clear,
  vDose:vDose, vFlow:vFlow, vB:vB, vBBB:vBBB, vPulse:vPulse, vRel:vRel, vLeak:vLeak, vClear:vClear,
  inject:inject, boost:boost, reset:reset,
  kReach:kReach, kAUCT:kAUCT, kTox:kTox, kCtrl:kCtrl, status:status
};

const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const rand=(a,b)=>a+Math.random()*(b-a);

function sync(){
  ui.vDose.textContent=ui.dose.value;
  ui.vFlow.textContent=ui.flow.value;
  ui.vB.textContent=ui.B.value;
  ui.vBBB.textContent=ui.bbb.value;
  ui.vPulse.textContent=ui.pulse.value;
  ui.vRel.textContent=ui.rel.value;
  ui.vLeak.textContent=ui.leak.value;
  ui.vClear.textContent=ui.clear.value;
}
["input","change"].forEach(ev=>{
  ui.dose.addEventListener(ev,sync);
  ui.flow.addEventListener(ev,sync);
  ui.B.addEventListener(ev,sync);
  ui.bbb.addEventListener(ev,sync);
  ui.pulse.addEventListener(ev,sync);
  ui.rel.addEventListener(ev,sync);
  ui.leak.addEventListener(ev,sync);
  ui.clear.addEventListener(ev,sync);
});
sync();

// Zonas (sangre arriba, BBB en medio, tumor abajo)
const blood = {x:70,y:110,w:cv.width-140,h:240,r:26};
const bbbLineY = blood.y + blood.h + 35;
const brain = {x:70,y:bbbLineY+25,w:cv.width-140,h:cv.height-(bbbLineY+45),r:26};
const tumor = {x:cv.width-290, y:brain.y+brain.h*0.55, r:95};

// Heatmap (tumor)
const HM=32;
let hm = new Float32Array(HM*HM);
const hidx=(i,j)=>i*HM+j;

function hmCell(x,y){
  const rx=(x-(tumor.x-tumor.r))/(tumor.r*2);
  const ry=(y-(tumor.y-tumor.r))/(tumor.r*2);
  const j=clamp(Math.floor(rx*HM),0,HM-1);
  const i=clamp(Math.floor(ry*HM),0,HM-1);
  return {i,j};
}

let bots=[], total=0, arrived=0;
let aucTum=0, aucSano=0;
let ctrl=85; // ‚Äúcontrol tumoral‚Äù (%), inicia alto como en tu panel
let mode="idle"; // idle | inject | sim
let injT=0;
let needle={x:200,y:-140, plunger:0};

function typeMul(){
  const t=ui.type.value;
  if(t==="mag") return {guide:1.2, bind:1.0, leak:1.0};
  if(t==="lig") return {guide:0.85, bind:1.25, leak:0.95};
  return {guide:1.15, bind:1.15, leak:1.05};
}

function resetAll(){
  bots=[]; hm.fill(0);
  total=0; arrived=0; aucTum=0; aucSano=0; ctrl=85;
  mode="idle"; injT=0; needle={x:200,y:-140,plunger:0};
  ui.status.textContent="Estado: esperando inyecci√≥n.";
  pushMetrics(0,0,0,ctrl);
  ui.kReach.textContent="0%";
  ui.kAUCT.textContent="0.0";
  ui.kTox.textContent="0%";
  ui.kCtrl.textContent=ctrl+"%";
}

function spawn(mult=1){
  const n=Math.max(90, Math.floor(parseInt(ui.dose.value,10)*mult));
  total += n;
  for(let i=0;i<n;i++){
    bots.push({
      x: blood.x + rand(10,60),
      y: blood.y + rand(10,blood.h-10),
      vx:0,vy:0,
      drug:1.0,
      crossed:false,
      stuck:false,
      alive:true
    });
  }
}

function startInjection(){
  resetAll();
  mode="inject";
  injT=0;
  spawn(1);
  ui.status.textContent="üíâ Inyecci√≥n IV: nanorrobots entrando al vaso sangu√≠neo‚Ä¶";
}

function flowField(y){
  const center=blood.y+blood.h/2;
  const R=blood.h/2;
  const d=y-center;
  const profile=clamp(1-(d*d)/(R*R),0,1);
  return profile * parseFloat(ui.flow.value);
}

function pushMetrics(reachPct=0, doseTum=0, tox=0, ctrlPct=85){
  // Mantiene el formato que usa tu index.html (NANO_METRICS)
  window.parent?.postMessage({
    type:"NANO_METRICS",
    payload:{
      reachPct: reachPct,
      doseTumor: doseTum,   // aqu√≠ usamos AUC tumor simulada
      toxicity: tox,        // exposici√≥n en tejido sano (0..100)
      tumorPct: ctrlPct     // control tumoral (0..100)
    }
  },"*");
}

function step(dt){
  const M=typeMul();

  const B = (parseFloat(ui.B.value)/100) * M.guide;          // gu√≠a magn√©tica
  const BBB = (parseFloat(ui.bbb.value)/100);               // permeabilidad BBB
  const pulse = (parseFloat(ui.pulse.value)/100);           // pulsos (cu√°ndo)
  const rel = (parseFloat(ui.rel.value)/100);               // cu√°nto libera
  const leak = (parseFloat(ui.leak.value)/100) * M.leak;    // fuga fuera objetivo
  const clear = (parseFloat(ui.clear.value)/100);           // aclaramiento

  // decaimiento heatmap
  const hmDecay = clamp(0.08 + clear*0.10, 0.04, 0.28);
  for(let k=0;k<hm.length;k++) hm[k] *= (1-hmDecay*dt);

  // prob de eliminaci√≥n
  const kill = clamp(clear*0.13*dt, 0, 0.10);

  for(const b of bots){
    if(!b.alive) continue;
    if(Math.random()<kill){ b.alive=false; continue; }

    // 1) Movimiento en sangre
    if(!b.crossed){
      const v = flowField(b.y);
      const brown=0.6;
      b.vx = v*3.1 + rand(-brown,brown);
      b.vy = rand(-brown,brown);

      // gu√≠a magn√©tica hacia ‚Äúzona de cruce‚Äù cerca del tumor
      const dx = tumor.x - b.x;
      const dy = (bbbLineY+20) - b.y; // hacia BBB
      const dist = Math.hypot(dx,dy)+1e-6;

      // se activa m√°s cuando avanza en el vaso
      const gate = clamp((b.x-(blood.x+blood.w*0.55))/(blood.w*0.45), 0, 1);
      const pull = B * gate;

      b.vx += (dx/dist)*pull*3.0;
      b.vy += (dy/dist)*pull*3.0;

      b.x += b.vx*70*dt;
      b.y += b.vy*70*dt;

      // paredes vaso
      if(b.y < blood.y+6) b.y=blood.y+6;
      if(b.y > blood.y+blood.h-6) b.y=blood.y+blood.h-6;

      // recirculaci√≥n
      if(b.x > blood.x + blood.w + 60){
        b.x = blood.x + rand(10,60);
        b.y = blood.y + rand(10,blood.h-10);
      }

      // 2) Cruce de BBB (prob depende de BBB + gu√≠a)
      const nearBBB = (b.y > blood.y + blood.h - 18) && (b.x > blood.x + blood.w*0.60);
      if(nearBBB){
        const pCross = clamp((0.02 + 0.28*BBB + 0.22*B) * dt * 6, 0, 0.55);
        if(Math.random() < pCross){
          b.crossed = true;
          // aparece en ‚Äúcerebro‚Äù
          b.y = brain.y + rand(10,40);
          b.x = clamp(b.x + rand(-10,10), brain.x+10, brain.x+brain.w-10);
        }
      }

      // fuga fuera objetivo mientras circula (sist√©mica)
      if(b.drug>0){
        const out = Math.min(b.drug, leak*0.020);
        b.drug -= out;
        aucSano += out;
      }
      continue;
    }

    // 3) En cerebro (debajo BBB): mover hacia tumor
    const brown=0.55;
    const dx=tumor.x-b.x, dy=tumor.y-b.y;
    const dist=Math.hypot(dx,dy)+1e-6;

    const guideBrain = (0.6 + 1.2*B) * 0.8;
    b.vx = (dx/dist)*guideBrain + rand(-brown,brown);
    b.vy = (dy/dist)*guideBrain + rand(-brown,brown);

    b.x += b.vx*55*dt;
    b.y += b.vy*55*dt;

    // l√≠mites cerebro
    b.x = clamp(b.x, brain.x+8, brain.x+brain.w-8);
    b.y = clamp(b.y, brain.y+8, brain.y+brain.h-8);

    // 4) Tumor: liberar con pulsos
    const inTum = Math.hypot(b.x-tumor.x, b.y-tumor.y) < tumor.r;

    if(inTum && !b.stuck){
      b.stuck = true;
      arrived++;
    }

    if(inTum && b.drug>0){
      // pulsos = ‚Äúventana‚Äù de liberaci√≥n
      const pulseGate = (Math.sin(performance.now()/500) * 0.5 + 0.5); // 0..1
      const pulseOn = (pulseGate < pulse); // si pulso alto, se activa m√°s tiempo

      if(pulseOn){
        const relRate = 0.010 + 0.050*rel;
        const d = Math.min(b.drug, relRate*2.4);
        b.drug -= d;
        aucTum += d;

        // heatmap
        const {i,j}=hmCell(b.x,b.y);
        const cell=(tumor.r*2)/HM;
        const cx=(tumor.x-tumor.r)+(j+0.5)*cell;
        const cy=(tumor.y-tumor.r)+(i+0.5)*cell;
        if((cx-tumor.x)**2 + (cy-tumor.y)**2 <= tumor.r*tumor.r){
          hm[hidx(i,j)] += d*2.4;
        }
      }
    }

    // peque√±a fuga a√∫n en cerebro
    if(b.drug>0){
      const out = Math.min(b.drug, leak*0.010);
      b.drug -= out;
      aucSano += out;
    }
  }

  // m√©tricas
  const reachPct = total>0 ? (arrived/total)*100 : 0;
  const tox = clamp((aucSano/Math.max(1,total))*6000, 0, 100); // 0..100

  // ‚Äúcontrol tumoral‚Äù: sube con AUC tumor, baja con tox (s√∫per f√°cil de entender)
  const benefit = clamp(aucTum*0.035, 0, 70);
  const harm = clamp(tox*0.35, 0, 50);
  ctrl = clamp(35 + benefit - harm, 0, 100);

  ui.kReach.textContent = Math.round(reachPct)+"%";
  ui.kAUCT.textContent = aucTum.toFixed(1);
  ui.kTox.textContent = Math.round(tox)+"%";
  ui.kCtrl.textContent = Math.round(ctrl)+"%";

  // mandar al index (2 veces por segundo aprox)
  pushMetrics(reachPct, aucTum, tox, ctrl);
}

function roundRect(x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

function drawHeatmap(){
  const cell=(tumor.r*2)/HM;
  const maxV=0.9;
  for(let i=0;i<HM;i++){
    for(let j=0;j<HM;j++){
      const v=hm[hidx(i,j)];
      if(v<0.002) continue;
      const x=(tumor.x-tumor.r)+j*cell;
      const y=(tumor.y-tumor.r)+i*cell;
      const cx=x+cell/2, cy=y+cell/2;
      if((cx-tumor.x)**2 + (cy-tumor.y)**2 > tumor.r*tumor.r) continue;
      const a=clamp(v/maxV,0,1);
      ctx.fillStyle=`rgba(${Math.round(255*a)},${Math.round(210*a)},${Math.round(70*a)},${0.30*a})`;
      ctx.fillRect(x,y,cell,cell);
    }
  }
}

function drawNeedle(){
  const x=needle.x, y=needle.y;

  // jeringa
  ctx.fillStyle="rgba(255,255,255,.85)";
  ctx.fillRect(x-20, y-30, 85, 24);

  // √©mbolo
  ctx.fillStyle="rgba(233,236,255,.85)";
  ctx.fillRect(x-18 + needle.plunger*46, y-28, 10, 20);

  // tubo
  ctx.fillStyle="rgba(255,255,255,.92)";
  ctx.fillRect(x+14, y-8, 14, 150);

  // agarre
  ctx.fillStyle="rgba(255,255,255,.70)";
  ctx.fillRect(x, y+40, 44, 18);

  // punta
  ctx.fillStyle="rgba(251,191,36,.90)";
  ctx.beginPath();
  ctx.moveTo(x+21, y+138);
  ctx.lineTo(x+36, y+170);
  ctx.lineTo(x+6,  y+170);
  ctx.closePath();
  ctx.fill();

  // ‚Äúbolo‚Äù entrando al vaso
  ctx.fillStyle="rgba(56,189,248,.85)";
  ctx.beginPath();
  ctx.arc(x+21, y+172, 7, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle="rgba(233,236,255,.85)";
  ctx.font="bold 14px Arial";
  ctx.fillText("Inyecci√≥n IV", x+60, y-10);
}

function draw(){
  ctx.clearRect(0,0,cv.width,cv.height);

  // fondo
  const g=ctx.createLinearGradient(0,0,0,cv.height);
  g.addColorStop(0,"#000"); g.addColorStop(1,"#020617");
  ctx.fillStyle=g; ctx.fillRect(0,0,cv.width,cv.height);

  // t√≠tulos
  ctx.fillStyle="rgba(233,236,255,.92)";
  ctx.font="bold 20px Arial";
  ctx.fillText("Sangre ‚Üí BBB ‚Üí Tumor cerebral (gu√≠a magn√©tica + liberaci√≥n controlada)", 18, 34);
  ctx.font="13px Arial";
  ctx.fillStyle="rgba(233,236,255,.70)";
  ctx.fillText("Azul: con f√°rmaco ‚Ä¢ Amarillo: descargados ‚Ä¢ Heatmap: f√°rmaco en tumor", 18, 56);

  // sangre (vaso)
  roundRect(blood.x,blood.y,blood.w,blood.h,blood.r);
  ctx.fillStyle="rgba(148,163,184,.08)"; ctx.fill();
  ctx.strokeStyle="rgba(56,189,248,.25)"; ctx.lineWidth=2; ctx.stroke();

  // BBB
  ctx.strokeStyle="rgba(255,255,255,.25)";
  ctx.setLineDash([8,8]);
  ctx.beginPath();
  ctx.moveTo(80, bbbLineY);
  ctx.lineTo(cv.width-80, bbbLineY);
  ctx.stroke();
  ctx.setLineDash([]);

  ctx.fillStyle="rgba(233,236,255,.75)";
  ctx.font="bold 13px Arial";
  ctx.fillText("BBB (barrera hematoencef√°lica)", 90, bbbLineY-10);

  // cerebro
  roundRect(brain.x,brain.y,brain.w,brain.h,brain.r);
  ctx.fillStyle="rgba(167,139,250,.07)"; ctx.fill();
  ctx.strokeStyle="rgba(167,139,250,.20)"; ctx.lineWidth=2; ctx.stroke();

  // tumor halo + heatmap
  const halo=ctx.createRadialGradient(tumor.x,tumor.y,10,tumor.x,tumor.y,tumor.r*2.3);
  halo.addColorStop(0,"rgba(167,139,250,.16)");
  halo.addColorStop(1,"rgba(167,139,250,0)");
  ctx.fillStyle=halo;
  ctx.beginPath(); ctx.arc(tumor.x,tumor.y,tumor.r*2.3,0,Math.PI*2); ctx.fill();

  drawHeatmap();

  ctx.beginPath(); ctx.arc(tumor.x,tumor.y,tumor.r,0,Math.PI*2);
  ctx.fillStyle="rgba(167,139,250,.12)"; ctx.fill();
  ctx.lineWidth=6; ctx.strokeStyle="rgba(56,189,248,.45)"; ctx.stroke();

  // bots
  for(const b of bots){
    if(!b.alive) continue;
    const loaded=b.drug>0.6;
    ctx.fillStyle = loaded ? "rgba(56,189,248,.92)" : "rgba(251,191,36,.92)";
    ctx.beginPath();
    ctx.arc(b.x,b.y, b.stuck?3.9:3.0, 0, Math.PI*2);
    ctx.fill();
  }

  // aguja
  if(mode==="inject") drawNeedle();
}

let last=performance.now();
function loop(now){
  const dt=clamp((now-last)/1000,0,0.05);
  last=now;

  if(mode==="inject"){
    injT += dt;
    const enter = Math.min(1, injT/1.1);
    needle.y = -140 + enter*(blood.y+35);
    needle.plunger = clamp((injT-0.55)/1.2, 0, 1);

    // durante inyecci√≥n, mete m√°s part√≠culas ‚Äúen bolo‚Äù
    if(injT < 2.0 && Math.random()<0.30) spawn(0.06);

    if(injT >= 2.3){
      mode="sim";
      ui.status.textContent="‚úÖ Inyecci√≥n finalizada. Simulaci√≥n activa.";
    }
  }

  if(mode==="sim") step(dt);

  draw();
  requestAnimationFrame(loop);
requestAnimationFrame(loop);

// Botones
ui.inject.onclick=()=>startInjection();
ui.boost.onclick=()=>{
  if(mode==="idle") startInjection();
  spawn(0.35);
  ui.status.textContent="‚ûï Refuerzo aplicado (m√°s nanorrobots).";
};
ui.reset.onclick=()=>resetAll();

// Inicio
resetAll();
</script>
</body
</body>
</html>
